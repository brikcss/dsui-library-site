/** ------------------------------------------------------------------------------------------------
 *  lint-staged-files.js
 *  --------------------
 *  @author  brikcss <https://github.com/brikcss>
 *  @description  This script runs code linters and formatters **only on staged files**. This means
 *    we don't have to run them during dev build, speeding it up.
 *  @param  {list}  [ignore]  Comma-separated list of file types to ignore (js, json, or css).
 *  @param  {list}  [js]  JS file extensions to lint (.js).
 *  @param  {list}  [json]  JSON file extensions to lint (.json).
 *  @param  {list}  [css]  CSS file extensions to lint (.css,.scss).
 ** --------------------------------------------------------------------------------------------- */
/* eslint-env node, es6 */

// -------------------
// Set up environment.
//
const tim = require('@brikcss/tim');
const promises = [];
const options = tim.minimist(process.argv.slice(1));

// ----------------------
// Get the party started.
//
tim.log.info('\n [i] Running precommit linters...\n');

// --------------------------------------------
// Get filepaths for staged JS/JSON/SASS files.
//
let files = {
	js: [],
	json: [],
	css: [],
	staged: [],
	partiallyUnstaged: [],
};
options.ignore = options.ignore ? options.ignore.split(',') : [];
const fileExts = {};
if (options.ignore.indexOf('js') === -1) fileExts.js = options.js ? options.js.split(',') : ['.js'];
if (options.ignore.indexOf('json') === -1)
	fileExts.json = options.json ? options.json.split(',') : ['.json'];
if (options.ignore.indexOf('css') === -1)
	fileExts.css = options.css ? options.css.split(',') : ['.css', '.scss'];

// Status codes (https://git-scm.com/docs/git-status):
//   ' ' = File changed since added to index.
//   'D' = File deleted.
//   '?' = Untracked file.
const statusCodesToIgnore = [' ', 'D', '?'];
// Loop through all modified styles and cache to various file types we're interested in.
tim.shell
	.exec('git status --porcelain', { silent: true })
	.stdout.split('\n')
	.forEach(function(file) {
		file = {
			status: file.slice(0, 2),
			path: file.slice(3),
		};
		// If file was Renamed ('R'), grab the renamed path. Renamed filepaths are stored like this:
		// RM example.txt -> build/example.txt
		if (file.status[0] === 'R') {
			file.path = file.path.slice(file.path.indexOf('-> ') + 3);
		}

		// Use cases to skip:
		//   - package.json (frequently modified by npm)
		//   - package-lock.json (auto-generated by npm)
		//   - file paths that include `statusCodesToIgnore`
		if (
			tim.path.basename(file.path) === 'package-lock.json' ||
			tim.path.basename(file.path) === 'package.json' ||
			statusCodesToIgnore.indexOf(file.status[0]) > -1
		) {
			return true;
		}

		// Cache all staged filepaths.
		files.staged.push(file.path);

		// Cache staged files that have the extensions we're in.
		Object.keys(fileExts).some(function(key) {
			if (fileExts[key].indexOf(tim.path.extname(file.path)) > -1) {
				files[key].push(file.path);

				// Cache partially unstaged files. NOTE: Partially unstaged files have both staged
				// and unstaged portions. The reason we need to stash these is because the linters
				// may modify and add files. If there are partially unstaged files, the unstaged
				// portions would get added, undesirably so.
				if (file.status[1] !== ' ') {
					// Get content if the file is modified.
					if (file.status[1] === 'M') {
						file.content = tim.fs.readFileSync(file.path);
					}
					// Cache the file.
					files.partiallyUnstaged.push(file);
					// Remove unstaged changes.
					tim.shell.exec(`git checkout -- ${file.path}`);
				}
				return true;
			}
		});
	});
tim.log.debug(files);

// -----------------------------------------
// Exit if no JS/JSON/SASS files are staged.
//
if (!files.js.length && !files.css.length && !files.json.length) {
	tim.log.warn(`\n [ok] No staged ${fileExts.join('/')} files to lint.`);
	process.exit(0);
}

// ----------------------------
// Process each group of files.
//

// Process SASS files: prettier > stylelint > git add.
if (files.css.length) {
	tim.log.info(
		`     CSS: ${
			files.css.length > 3 ? files.css.length + ' files staged...' : files.css.join(', ')
		}`
	);
	promises.push(
		createPromise(
			`node ./node_modules/.bin/prettier ${files.css.join(
				' '
			)} --write --loglevel=error --color=always && node ./node_modules/.bin/stylelint ${files.css.join(
				' '
			)} --color always`
		)
	);
} else {
	tim.log.info('     CSS: None staged');
}

// Process JS files: prettier > eslint > git add.
if (files.js.length) {
	tim.log.info(
		`     JS: ${files.js.length > 3 ? files.js.length + ' files staged...' : files.js.join(', ')}`
	);
	promises.push(
		createPromise(
			`node ./node_modules/.bin/prettier ${files.js.join(
				' '
			)} --write --loglevel=error --color=always && node ./node_modules/.bin/eslint ${files.js.join(
				' '
			)} --color always --fix`
		)
	);
} else {
	tim.log.info('     JS: None staged');
}

// Process JSON files: prettier > git add.
if (files.json.length) {
	tim.log.info(
		`     JSON: ${
			files.json.length > 3 ? files.json.length + ' files staged...' : files.json.join(', ')
		}`
	);
	promises.push(
		createPromise(
			`node ./node_modules/.bin/prettier ${files.json.join(
				' '
			)} --write --loglevel=error --color=always`
		)
	);
} else {
	tim.log.info('     JSON: None staged');
}

// ----------------------------------------------------
// Process results after all file groups are processed.
//
try {
	Promise.all(promises)
		.then((results) => {
			let errors = [];
			// Check for errors.
			results.forEach(function(result) {
				if (!result.success) {
					errors.push(result.error);
				}
			});
			// Throw any errors now.
			if (errors.length) {
				throwError(errors);
			} else {
				// If there are no errors, add newly formatted/linted files to the commit, then reset stage.
				tim.shell.exec(`git add ${files.staged.join(' ')}`);
				resetStage();
			}
			// Notify user.
			tim.log.warn('\n[ok] Done! Committing changes...');
			return;
		})
		.catch((errors) => throwError(errors, 'Uh oh... there was a problem...'));
} catch (error) {
	tim.log.error('\n[!!] Uh oh... there was a problem...\n', error);
	process.exit(1);
}

// ----------
// Functions.
//

/**
 *  Create a promise to run an asyncronous command via tim.shell.exec().
 *
 *  @param   {string}  stringCommand  Command to run via tim.shell.exec().
 *  @return  {promise}  Promise to return command result.
 */
function createPromise(stringCommand) {
	return new Promise(function(resolve) {
		tim.shell.exec(stringCommand, { async: true, silent: true }, function(code, stdout, stderr) {
			if (code > 0) {
				let error = {
					code,
					message: stderr || stdout,
				};
				if (error.message) {
					error.message = '     ' + error.message.replace(/\n/g, '\n     ');
				}
				resolve({
					success: false,
					error,
				});
			} else if (stdout.trim().length) {
				tim.log.warn('     ' + stdout.trim().replace(/\n/g, '\n     '));
			}
			resolve({ success: true });
		});
	});
}

/**
 *  Throw an error and exit without committing.
 *
 *  @param   {array|object|string}  errors  Error to throw.
 *  @param   {string}  introMsg  Message to show at beginning.
 *  @return  {boolean}  Always returns false.
 */
function throwError(
	errors,
	introMsg = 'Uh oh... there are errors you need to fix before you can commit these changes...'
) {
	// Log intro message.
	tim.log.error(`\n[!!] ${introMsg}\n`);
	// Log each error.
	if (errors instanceof Array) {
		errors.forEach(function(error) {
			if (error.message) {
				tim.log.error(error.message);
			}
		});
	} else {
		tim.log.error(errors);
	}
	// Reset the git state.
	resetStage();
	// Exit with error code 1.
	process.exit(1);
	return false;
}

/**
 *  Reset git's stage and reapply files that were previously partially unstaged.
 */
function resetStage() {
	const filesToReset = files.staged.join(' ');
	// Reset the stage.
	tim.shell.exec(`git checkout -- ${filesToReset}`);
	// Restore cached partially unstaged files to their original form.
	if (files.partiallyUnstaged.length) {
		tim.log.info('\n\n [i] Reapplying partially unstaged changes...\n');
		files.partiallyUnstaged.forEach((file) => {
			// Restore modified and deleted files.
			if (file.status === 'M') {
				tim.log.info(` [i] Restoring ${file.path}...`);
				tim.fs.writeFileSync(file.path, file.content);
			} else if (file.status === 'D') {
				tim.log.info(` [i] Removing ${file.path}...`);
				tim.fs.unlinkSync(file.path);
			}
		});
	}
}
